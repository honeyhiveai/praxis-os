# Execute Tasks

Execute tasks from a specification's tasks.md file, following the breakdown systematically.

## Usage

**Trigger phrases:**
- "Execute tasks from [spec-path]"
- "Let's implement [spec-name]"
- "Work through the tasks for [feature]"

## Workflow

### 1. Locate Spec
```
Find: .praxis-os/specs/YYYY-MM-DD-feature-name/
Required files:
  - tasks.md (task breakdown)
  - specs.md (technical design)
  - implementation.md (guidance)
```

### 2. Load Context

**Query standards:**
```
Use MCP: search_standards("production code checklist")
Use MCP: search_standards("[relevant technical topic]")
```

**Review spec files:**
- Read specs.md for architecture
- Read implementation.md for patterns
- Read tasks.md for task list

### 3. Execute Phase by Phase

**For each phase in tasks.md:**

#### A. Show Phase Overview
```
Phase [N]: [Phase Name]
Goal: [What this phase achieves]
Tasks: [List of tasks]
Validation Gate: [Criteria to advance]
```

#### B. Execute Each Task
For each task:

1. **Read Task Details**
   ```
   Task X.Y: [Description]
   - Estimated Time: [time]
   - Dependencies: [prior tasks]
   - Acceptance Criteria: [checklist]
   ```

2. **Query Relevant Standards**
   ```
   Use MCP: search_standards("[task-specific topic]")
   ```

3. **Implement**
   - Follow implementation.md patterns
   - Apply production code checklist:
     * Sphinx docstrings
     * Type hints
     * Error handling
     * Tests
     * Concurrency analysis if needed

4. **Validate**
   - Check acceptance criteria
   - Run tests
   - Review against standards

5. **Mark Complete**
   ```
   âœ… Task X.Y: [Description] - COMPLETE
   Evidence: [what was done]
   ```

#### C. Phase Validation Gate
Before advancing:
- [ ] All tasks in phase complete
- [ ] All tests passing
- [ ] Phase deliverables created
- [ ] Validation criteria met

#### D. Advance to Next Phase
```
âœ… Phase [N] Complete
Moving to Phase [N+1]...
```

### 4. Implementation Standards

**EVERY code change must include:**
- [ ] Sphinx-style docstrings (`:param`, `:return`, `:raises`, example)
- [ ] Complete type annotations
- [ ] Error handling (specific exceptions, no bare except)
- [ ] Unit tests (happy path + failure modes)
- [ ] Concurrency safety analysis (if shared state)
- [ ] Resource lifecycle management (if needed)

**Query production checklist:**
```
Use MCP: search_standards("production code checklist")
```

### 5. Track Progress

**After each task:**
```
Progress: Phase [N] - [X/Y] tasks complete
Next: Task [N.Y+1]
```

**After each phase:**
```
âœ… Phase [N] Complete: [Phase Name]
ðŸ“Š Project Status: [N/Total] phases complete
```

### 6. Completion

**When all phases done:**
1. Run full test suite
2. Update roadmap (if exists)
3. Generate completion summary:
   ```
   âœ… [Feature Name] Implementation Complete
   
   Phases Completed: [N]
   Tasks Completed: [X]
   Time: [duration]
   
   Files Modified:
   - [file list]
   
   Tests: [X passing]
   Coverage: [%]
   
   Next Steps: [if any]
   ```

## Best Practices

### During Implementation
- Work on ONE task at a time (horizontal scaling)
- Complete each task fully before moving on
- Don't skip validation gates
- Query standards when uncertain

### Code Quality
- Follow specs.md design decisions
- Use implementation.md patterns
- Apply production code checklist
- Write tests alongside code (TDD)

### If Stuck
- Re-read specs.md for design intent
- Check implementation.md for patterns
- Query standards: `search_standards("[topic]")`
- Ask user for clarification if needed

## Output

- Feature fully implemented per spec
- All tests passing
- Documentation complete
- Production-ready code

## Related Commands

- `create-spec` - Create the spec first
- `query-standards` - Search standards
- `start-workflow` - Use workflow engine (alternative approach)